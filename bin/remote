#!/usr/bin/env bash
#
# Author: Davide Galassi <davxy@datawok.net>
# Version: 0.3.0
#
# Utility for common "remote" actions

REMOTE_NAME="behemoth"
MACADDR="d8:5e:d3:02:ed:00"
SMB_USER="davxy"
MOUNT_POINT="/home/${SMB_USER}/${REMOTE_NAME}"
WM="niri"

if [[ ${HOSTNAME} == ${REMOTE_NAME} ]]; then
    echo "Currently logged in ${REMOTE_NAME}"
    exit
fi

function remote_start() {
    echo "Sending wake-on-LAN packet to ${REMOTE_NAME}..."
    wol ${MACADDR}
    
    if [[ $1 == "--wait" ]]; then
        echo "Waiting for ${REMOTE_NAME} to come online..."
        local attempts=0
        local max_attempts=30
        
        while [[ $attempts -lt $max_attempts ]]; do
            if ping -c 1 -W 2 ${REMOTE_NAME} &>/dev/null; then
                echo "✓ ${REMOTE_NAME} is now online!"
                return 0
            fi
            echo -n "."
            sleep 2
            ((attempts++))
        done
        
        echo ""
        echo "✗ ${REMOTE_NAME} did not come online within 60 seconds"
        return 1
    fi
}

function remote_stop() {
    ssh remote shutdown -h now
}

function remote_mount() {
    dir=$1
    if [[ $dir == "" ]]; then
        dir="data"
    fi
    mkdir -p ${MOUNT_POINT}/${dir}
    target=${MOUNT_POINT}/${dir}
    echo "Mounting ${target}"
    sudo mount -t cifs -ouser=${SMB_USER} //${REMOTE_NAME}/${dir} ${target}
}

function remote_umount() {
    dir=$1
    if [[ $dir == "" ]]; then
        dir="data"
    fi
    target=${MOUNT_POINT}/${dir}
    echo "Umounting ${target}"
    sudo umount ${target}
}

function remote_status() {
    echo "Checking ${REMOTE_NAME} status..."
    if ping -c 1 -W 2 ${REMOTE_NAME} &>/dev/null; then
        echo "✓ ${REMOTE_NAME} is reachable"
        if ssh -o ConnectTimeout=5 ${REMOTE_NAME} true &>/dev/null; then
            echo "✓ SSH connection successful"
        else
            echo "✗ SSH connection failed"
        fi
    else
        echo "✗ ${REMOTE_NAME} is not reachable"
    fi
}

function remote_ssh() {
    echo "Connecting to ${REMOTE_NAME}..."
    ssh ${REMOTE_NAME}
}

function remote_copy() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: remote copy <source> <destination>"
        echo "Examples:"
        echo "  remote copy file.txt remote:~/        # Copy to remote"
        echo "  remote copy remote:~/file.txt .       # Copy from remote"
        return 1
    fi
    
    source=$1
    dest=$2
    
    # Replace 'remote:' with actual hostname
    source=${source/remote:/${REMOTE_NAME}:}
    dest=${dest/remote:/${REMOTE_NAME}:}
    
    echo "Copying ${source} to ${dest}..."
    scp -r "${source}" "${dest}"
}

function remote_sway() {
    echo "Starting remote wm session..."
    waypipe ssh ${REMOTE_NAME} $WM
}

function remote_logs() {
    local lines=${1:-50}
    echo "Fetching last ${lines} lines from ${REMOTE_NAME} system logs..."
    ssh ${REMOTE_NAME} "journalctl -n ${lines} --no-pager"
}

function remote_sync() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: remote sync <local_path> <remote_path> [--dry-run]"
        echo "Examples:"
        echo "  remote sync ./docs/ ~/documents/     # Sync to remote"
        echo "  remote sync ~/documents/ ./docs/     # Sync from remote"
        echo "  remote sync ./docs/ ~/documents/ --dry-run  # Preview changes"
        return 1
    fi
    
    local local_path=$1
    local remote_path=$2
    local dry_run=""
    
    if [[ $3 == "--dry-run" ]]; then
        dry_run="--dry-run"
        echo "DRY RUN - No files will be modified"
    fi
    
    # Determine sync direction based on paths
    if [[ $local_path == *":"* ]]; then
        # Syncing from remote to local
        local_path=${local_path/remote:/${REMOTE_NAME}:}
        echo "Syncing from ${local_path} to ${remote_path}..."
        rsync -avz --progress ${dry_run} "${local_path}" "${remote_path}"
    elif [[ $remote_path == *":"* ]]; then
        # Syncing from local to remote
        remote_path=${remote_path/remote:/${REMOTE_NAME}:}
        echo "Syncing from ${local_path} to ${remote_path}..."
        rsync -avz --progress ${dry_run} "${local_path}" "${remote_path}"
    else
        echo "Error: One path must be prefixed with 'remote:'"
        return 1
    fi
}

function remote_info() {
    echo "Gathering system information from ${REMOTE_NAME}..."
    ssh ${REMOTE_NAME} '
        echo "=== System Information ==="
        echo "Hostname: $(hostname)"
        echo "Uptime: $(uptime -p)"
        echo "Load: $(uptime | cut -d"load average:" -f2)"
        echo ""
        echo "=== Memory Usage ==="
        free -h
        echo ""
        echo "=== Disk Usage ==="
        df -h / /home 2>/dev/null || df -h /
        echo ""
        echo "=== Network ==="
        ip addr show | grep "inet " | grep -v "127.0.0.1"
        echo ""
        echo "=== Active Services ==="
        systemctl list-units --state=running --no-pager | head -10
    '
}

function remote_tunnel() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: remote tunnel <local_port> <remote_port> [remote_host]"
        echo "Examples:"
        echo "  remote tunnel 8080 80           # Forward local 8080 to remote 80"
        echo "  remote tunnel 5432 5432         # Forward local 5432 to remote 5432"
        echo "  remote tunnel 3000 3000 localhost  # Explicit remote host"
        return 1
    fi
    
    local local_port=$1
    local remote_port=$2
    local remote_host=${3:-localhost}
    
    echo "Creating SSH tunnel: localhost:${local_port} -> ${REMOTE_NAME}:${remote_host}:${remote_port}"
    echo "Press Ctrl+C to close the tunnel"
    ssh -L ${local_port}:${remote_host}:${remote_port} ${REMOTE_NAME} -N
}

function remote_discover() {
    echo "Discovering devices on local network..."
    
    # Get the local network range from the default route
    local gateway_ip=$(ip route | grep default | head -1 | awk '{print $3}')
    
    if [[ -z $gateway_ip ]]; then
        echo "Could not determine gateway IP"
        return 1
    fi
    
    # Derive network range from gateway IP (assume /24 subnet)
    local network=$(echo $gateway_ip | sed 's/\.[0-9]*$/\.0\/24/')
    
    if [[ -z $network ]]; then
        echo "Could not determine local network range"
        return 1
    fi
    
    echo "Scanning network: $network"
    echo "This may take a moment..."
    echo ""
    
    # Use nmap to discover devices with MAC addresses (scan first 25 IPs only)
    local base_network=$(echo $gateway_ip | sed 's/\.[0-9]*$//')
    for i in {1..25}; do
        nmap -sn "${base_network}.${i}" >/dev/null 2>&1 &
    done
    wait
    
    echo "Discovered devices:"
    echo "==================="
    printf "%-15s %-17s %s\n" "IP Address" "MAC Address" "Hostname"
    echo "---------------------------------------------------"
    
    # Parse ARP table for discovered devices
    arp -a | while read line; do
        if [[ $line =~ \(([0-9.]+)\)\ at\ ([a-fA-F0-9:]+) ]]; then
            ip="${BASH_REMATCH[1]}"
            mac="${BASH_REMATCH[2]}"
            hostname=$(echo "$line" | awk '{print $1}')
            
            # Skip incomplete entries
            if [[ $mac != "<incomplete>" ]]; then
                printf "%-15s %-17s %s\n" "$ip" "$mac" "$hostname"
            fi
        fi
    done
    
    echo ""
    echo "Note: Only devices that responded to the network scan are shown."
    echo "Some devices may not respond to ping but still be reachable."
}

function check_dependencies() {
    local missing=()
    local cmd=$1
    
    case $cmd in
        "start"|"wake")
            if ! command -v wol &>/dev/null; then
                missing+=("wakeonlan")
            fi
            ;;
        "sway")
            if ! command -v waypipe &>/dev/null; then
                missing+=("waypipe")
            fi
            ;;
        "sync")
            if ! command -v rsync &>/dev/null; then
                missing+=("rsync")
            fi
            ;;
        "discover")
            if ! command -v nmap &>/dev/null; then
                missing+=("nmap")
            fi
            ;;
    esac
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "Missing dependencies for '$cmd': ${missing[*]}"
        echo "Please install them first."
        return 1
    fi
    
    return 0
}

# Check dependencies for commands that need them
check_dependencies $1 || exit 1

if [[ $1 == "start" ]]; then
    remote_start $2
elif [[ $1 == "stop" ]]; then
    remote_stop
elif [[ $1 == "mount" ]]; then
    remote_mount $2
elif [[ $1 == "umount" ]]; then
    remote_umount $2
elif [[ $1 == "wake" ]]; then
    remote_start $2
elif [[ $1 == "status" ]]; then
    remote_status
elif [[ $1 == "ssh" ]]; then
    remote_ssh
elif [[ $1 == "copy" ]]; then
    remote_copy $2 $3
elif [[ $1 == "sway" ]]; then
    remote_sway
elif [[ $1 == "logs" ]]; then
    remote_logs $2
elif [[ $1 == "sync" ]]; then
    remote_sync $2 $3 $4
elif [[ $1 == "info" ]]; then
    remote_info
elif [[ $1 == "tunnel" ]]; then
    remote_tunnel $2 $3 $4
elif [[ $1 == "discover" ]]; then
    remote_discover
else
    echo "Usage: remote <command>"
    echo ""
    echo "Available commands:"
    echo " start [--wait]  Wakeup (using 'wakeonlan'), optionally wait for online"
    echo " wake [--wait]   Alias for 'start'"
    echo " stop            Shutdown"
    echo " status          Check if remote is reachable and SSH works"
    echo " ssh             Connect via SSH"
    echo " mount [dir]     Mount remote share in 'behemoth/dir'"
    echo " umount [dir]    Umount remote share in 'behemoth/dir'"
    echo " copy <src> <dst> Copy files (use 'remote:' prefix for remote paths)"
    echo " sync <src> <dst> [--dry-run] Sync directories with rsync"
    echo " sway            Start and connect to a remote sway session (using 'waypipe')"
    echo " logs [lines]    View remote system logs (default: 50 lines)"
    echo " info            Show detailed remote system information"
    echo " tunnel <local> <remote> [host] Create SSH tunnel"
    echo " discover        Scan local network for devices and their MAC addresses"
    echo ""
    echo "Examples:"
    echo " remote start --wait"
    echo " remote status"
    echo " remote copy file.txt remote:~/"
    echo " remote sync ./docs/ remote:~/documents/"
    echo " remote sync remote:~/backup/ ./backup/ --dry-run"
    echo " remote logs 100"
    echo " remote tunnel 8080 80"
    echo " remote discover"
fi
